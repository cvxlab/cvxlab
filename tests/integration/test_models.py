"""
test_models.py

@author: Matteo V. Rocco
@institution: Politecnico di Milano

This module contains unit tests for different types of models in the package.
The tests are parameterized based on settings loaded from a YAML file. The 
settings specify the log level, the test methods to call on each model, and 
the paths and names of the models to test.

The module defines three sets of tests:
    - tests for feature models, regarding specific model capabilities;
    - tests for non-integrated linear models,
    - tests for integrated models (solved iteratively).

Each set of tests is generated by the 'create_test_function' function, 
which creates a test function that iterates over the specified models and calls 
the specified methods on each model.

The module raises a FileNotFoundError if the settings file does not exist.
"""
import os
from pathlib import Path
from typing import Dict
import pytest
import yaml

from cvxlab import Model


def create_test_function(
        models: Dict,
        models_dir_path: Path | str,
        methods: Dict
):
    """
    Creates a pytest test function for a set of models.
    The test function iterates over the specified models, initializes each model 
    with the specified directory path and settings, and calls the specified methods 
    on each model.

    Args:
        models (Dict): A dictionary containing the names of the models to test.
        models_dir_path (Path | str): The directory path where the models are located.
        methods (Dict): A dictionary containing the methods to call on each model 
            and the arguments to pass to each method.

    Returns:
        function: A pytest test function.

    Notes:
        The test function is parameterized with the names of the models.
        The test function initializes each model with the 'Model' class, passing 
            the model's name, the directory path, the log level, and a flag indicating 
            to use existing data.
        The test function calls each method on the model using the 'getattr' 
            function and passes the arguments specified in the 'methods' dictionary.
        If a method call raises an exception, the test function fails the test with 
            a message indicating the name of the model.
    """
    @pytest.mark.parametrize("model_name", models)
    def test_model(model_name: Dict):
        model = Model(
            model_dir_name=model_name,
            main_dir_path=models_dir_path,
            log_level=log_level,
            use_existing_data=True,
        )

        for method, kwargs in methods.items():
            try:
                getattr(model, method)(**kwargs)
            except Exception as e:
                pytest.fail(f"Test failed: {model_name}")

    return test_model


# load tests settings
root_path = Path(__file__).parent
tests_settings = root_path / 'tests_settings.yml'

if not tests_settings.exists():
    raise FileNotFoundError(
        f"Expected settings file does not exist: '{tests_settings}'")

with open(tests_settings, 'r') as file:
    settings = yaml.safe_load(file)


# fetch log level, method and fixtures path
log_level = settings['log_level']
fixtures_dir_path = root_path / 'fixtures'

# generating testing functions
test_model_features = create_test_function(
    models=os.listdir(fixtures_dir_path),
    models_dir_path=fixtures_dir_path,
    methods=settings['methods'],
)
